package com.liu.sourceProject.leetcode.number400;
/**
 * 二分容量
 * 分成 m 个子数组，假设整个数组和 为 sum，那么平均下来每个子数组为 sum / k
 * 因此二分容量的 最小值 left 为 sum / k, 容量最大值 right 为 sum
 * 如果 容量 mid 可以分成 m 个子数组，那么我们尝试缩减容量
 * 如果 容量 mid 分成的子数组个数 > m，表示容量太小，必须增大容量，才能减少分割的子数组的个数
 * 比如 m = 3
 * 假设容量为 10，即分成的每个子数组最大容量为 10，结果分成的子数组个数为 5 个，那么意味着每个子数组容量为 10 太少了
 * 导致每个子数组容纳的数太少，因此才需要多出 2 个子数组来存储，因此我们需要调高容量
 */

/**
 * 二分法
 * nums = [7,2,5,10,8]
 * m = 1，那么整个数组作为一部分，最小的最大值为 32
 * m = n，那么每个元素作为一个子数组，从所有元素选取最大值，最小的最大值小为 10
 * <p>
 * m 的取值范围为 1 <= m <= n，因此，最大值的最小值的范围为 [10, 32]
 * <p>
 * 我们利用二分法查找，找出符合 m 的最大值的最小的结果
 * 二分过程：
 * left = 10;
 * right = 32
 * mid = (left + right) >>> 1 = 21（这个 21 就是一个子数组的最大容量）
 * 我们假设刚开辟的用来存储的子数组个数 cnt = 1
 * 那么根据贪心思想，我们将数组元素按顺序逐个往里放
 * 因此就有如下过程：
 * 7 < 21
 * 7 + 2 < 21
 * 7 + 2 + 5 < 21
 * 7 + 2 + 5 + 10 > 21
 * 至此，我们可以看出一个 21 容量的子数组是无法容纳整个数组元素的，因此我们需要开辟第二个子数组来存储剩下的数组元素
 * cnt = cnt + 1 = 2
 * 10 < 21
 * 10 + 8 < 21
 * 我们发现，两个子数组可以将整个数组元素放入，而 cnt 刚好等于 m，因此 [7,2,5] 和 [10,8] 就是分割出来的两个子数组，最小的最大值为 18
 * <p>
 * 为什么是放入元素直到放不下为止？因为要求的是连续子数组，我们需要保证每个连续的子数组的元素和都尽可能的接近 21
 * <p>
 * 如果我们最终得到的 cnt > m，那么表示我们划分出太多的子数组，也就是意味着一个子数组的容量太少，我们需要再扩大容量，即 left = mid + 1，然后继续进行二分
 * 如果我们最终得到的 cnt < m，那么表示我们划分出太少的子数组，也就是意味着一个子数组的容量太大，需要减少容量，即 right = mid - 1
 */
public class Number410 {
    public int splitArray(int[] nums, int m) {
        long left = 0, right = 0;
        for (int num : nums) {
            left = Math.max(left, num);
            right += num;
        }

        while (left < right) {
            int c = 0;
            long mid = (left + right) >>> 1;
            long temp = 0;
            for (int num : nums) {
                if (temp + num > mid) {
                    c++;
                    temp = 0;
                }
                temp += num;
            }
            c++;
            if (c > m) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return (int) left;
    }
}
